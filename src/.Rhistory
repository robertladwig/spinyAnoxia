c10 = 0.9
c20 = 0.1
c1inf = (c10 + c20) / (a + 1)
dt = 0.1
t = seq(0, 4, dt)
c = c10/c1inf - 1
#### ANALYTICAL SOLUTION
c1 = (1 + c *  exp(-(a+1)* t)) * c1inf
c2 = c10 + c20 - c1
#### NUMERICAL EXPLICIT FORWARD EULER SOLUTION
c1euler = rep(NA, length(t))
c2euler = rep(NA, length(t))
c1euler[1] = c10
c2euler[1] = c20
for (i in t[2:length(t)]){
c1euler[match(i, t)] = c1euler[match(i, t) -1] +
dt * (c2euler[match(i, t) -1] - c1euler[match(i, t) -1] * a)
c2euler[match(i, t)] = c2euler[match(i, t) -1] +
dt * (a * c1euler[match(i, t) -1] - c2euler[match(i, t) -1])
}
#### NUMERICAL 4TH ORDER RUNGE KUTTA SOLUTION
c1rk = rep(NA, length(t))
c2rk = rep(NA, length(t))
c1rk[1] = c10
c2rk[1] = c20
for (i in t[2:length(t)]){
k1 = dc1dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
l1 = dc2dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
k2 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
l2 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
k3 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
l3 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
k4 = dc1dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
l4 = dc2dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
c1rk[match(i, t)] = c1rk[match(i, t) -1] +
dt * (1/6 * (k1 + 2 * k2 + 2 * k3 + k4))
c2rk[match(i, t)] = c2rk[match(i, t) -1] +
dt * (1/6 * (l1 + 2 * l2 + 2 * l3 + l4))
}
#### NUMERICAL EXPLICIT FORWARD EULER PATANKAR SOLUTION
c1pteuler = rep(NA, length(t))
c2pteuler = rep(NA, length(t))
c1pteuler[1] = c10
c2pteuler[1] = c20
for (i in t[2:length(t)]){
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
p1 = c1pteuler[match(i, t) -1]
p2 = a * c1pteuler[match(i, t) -1]
d1 = p2
d2 = p1
c1pteuler[match(i, t)] = (c1pteuler[match(i, t) -1] + dt * p1) /
(1 + dt * d1 / c1pteuler[match(i, t) -1])
c2pteuler[match(i, t)] = (c2pteuler[match(i, t) -1] + dt * p2) /
(1 + dt * d2 / c2pteuler[match(i, t) -1])
}
#### PLOTTING OF RESULTS
plot(t, c1, type = 'l', col = 'blue', ylim = c(-0.3, 1.3), xlab = 'time',
ylab = 'conc.')
lines(t, c1euler, type = 'l', col = 'blue', lty = 'dashed')
lines(t, c1rk, type = 'l', col = 'blue', lty = 'dotted')
lines(t, c1pteuler, type = 'l', col = 'blue', lty = 'dotdash')
lines(t, c2, col = 'red')
lines(t, c2euler, type = 'l', col = 'red', lty = 'dashed')
lines(t, c2rk, type = 'l', col = 'red', lty = 'dotted')
lines(t, c2pteuler, type = 'l', col = 'red', lty = 'dotdash')
legend(2., 1.1, legend=c("Analytical", "Explicit Euler", "Runge-Kutta 4th",
"Euler-Patankar"),
lty = c("solid","dashed","dotted",'dotdash')
)
# Burchard et al. (2003) "A high-order conservative Patankar-type discretisation
# for stiff systems of production–destruction equations
#### PROBLEM SET, TWO COUPLED ODES
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
dc1dt <- function(c1, c2, a){
return(c2 - a * c1)
}
dc2dt <- function(c1, c2, a){
return(a * c1 - c2)
}
#### PARAMETERS
a = 5
c10 = 0.9
c20 = 0.1
c1inf = (c10 + c20) / (a + 1)
dt = 0.3
t = seq(0, 4, dt)
c = c10/c1inf - 1
#### ANALYTICAL SOLUTION
c1 = (1 + c *  exp(-(a+1)* t)) * c1inf
c2 = c10 + c20 - c1
#### NUMERICAL EXPLICIT FORWARD EULER SOLUTION
c1euler = rep(NA, length(t))
c2euler = rep(NA, length(t))
c1euler[1] = c10
c2euler[1] = c20
for (i in t[2:length(t)]){
c1euler[match(i, t)] = c1euler[match(i, t) -1] +
dt * (c2euler[match(i, t) -1] - c1euler[match(i, t) -1] * a)
c2euler[match(i, t)] = c2euler[match(i, t) -1] +
dt * (a * c1euler[match(i, t) -1] - c2euler[match(i, t) -1])
}
#### NUMERICAL 4TH ORDER RUNGE KUTTA SOLUTION
c1rk = rep(NA, length(t))
c2rk = rep(NA, length(t))
c1rk[1] = c10
c2rk[1] = c20
for (i in t[2:length(t)]){
k1 = dc1dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
l1 = dc2dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
k2 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
l2 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
k3 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
l3 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
k4 = dc1dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
l4 = dc2dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
c1rk[match(i, t)] = c1rk[match(i, t) -1] +
dt * (1/6 * (k1 + 2 * k2 + 2 * k3 + k4))
c2rk[match(i, t)] = c2rk[match(i, t) -1] +
dt * (1/6 * (l1 + 2 * l2 + 2 * l3 + l4))
}
#### NUMERICAL EXPLICIT FORWARD EULER PATANKAR SOLUTION
c1pteuler = rep(NA, length(t))
c2pteuler = rep(NA, length(t))
c1pteuler[1] = c10
c2pteuler[1] = c20
for (i in t[2:length(t)]){
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
p1 = c1pteuler[match(i, t) -1]
p2 = a * c1pteuler[match(i, t) -1]
d1 = p2
d2 = p1
c1pteuler[match(i, t)] = (c1pteuler[match(i, t) -1] + dt * p1) /
(1 + dt * d1 / c1pteuler[match(i, t) -1])
c2pteuler[match(i, t)] = (c2pteuler[match(i, t) -1] + dt * p2) /
(1 + dt * d2 / c2pteuler[match(i, t) -1])
c2pteuler[match(i, t)]  = c10 + c20 - c1pteuler[match(i, t)]
}
#### PLOTTING OF RESULTS
plot(t, c1, type = 'l', col = 'blue', ylim = c(-0.3, 1.3), xlab = 'time',
ylab = 'conc.')
lines(t, c1euler, type = 'l', col = 'blue', lty = 'dashed')
lines(t, c1rk, type = 'l', col = 'blue', lty = 'dotted')
lines(t, c1pteuler, type = 'l', col = 'blue', lty = 'dotdash')
lines(t, c2, col = 'red')
lines(t, c2euler, type = 'l', col = 'red', lty = 'dashed')
lines(t, c2rk, type = 'l', col = 'red', lty = 'dotted')
lines(t, c2pteuler, type = 'l', col = 'red', lty = 'dotdash')
legend(2., 1.1, legend=c("Analytical", "Explicit Euler", "Runge-Kutta 4th",
"Euler-Patankar"),
lty = c("solid","dashed","dotted",'dotdash')
)
# Burchard et al. (2003) "A high-order conservative Patankar-type discretisation
# for stiff systems of production–destruction equations
#### PROBLEM SET, TWO COUPLED ODES
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
dc1dt <- function(c1, c2, a){
return(c2 - a * c1)
}
dc2dt <- function(c1, c2, a){
return(a * c1 - c2)
}
#### PARAMETERS
a = 5
c10 = 0.9
c20 = 0.1
c1inf = (c10 + c20) / (a + 1)
dt = 0.1
t = seq(0, 4, dt)
c = c10/c1inf - 1
#### ANALYTICAL SOLUTION
c1 = (1 + c *  exp(-(a+1)* t)) * c1inf
c2 = c10 + c20 - c1
#### NUMERICAL EXPLICIT FORWARD EULER SOLUTION
c1euler = rep(NA, length(t))
c2euler = rep(NA, length(t))
c1euler[1] = c10
c2euler[1] = c20
for (i in t[2:length(t)]){
c1euler[match(i, t)] = c1euler[match(i, t) -1] +
dt * (c2euler[match(i, t) -1] - c1euler[match(i, t) -1] * a)
c2euler[match(i, t)] = c2euler[match(i, t) -1] +
dt * (a * c1euler[match(i, t) -1] - c2euler[match(i, t) -1])
}
#### NUMERICAL 4TH ORDER RUNGE KUTTA SOLUTION
c1rk = rep(NA, length(t))
c2rk = rep(NA, length(t))
c1rk[1] = c10
c2rk[1] = c20
for (i in t[2:length(t)]){
k1 = dc1dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
l1 = dc2dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
k2 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
l2 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
k3 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
l3 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
k4 = dc1dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
l4 = dc2dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
c1rk[match(i, t)] = c1rk[match(i, t) -1] +
dt * (1/6 * (k1 + 2 * k2 + 2 * k3 + k4))
c2rk[match(i, t)] = c2rk[match(i, t) -1] +
dt * (1/6 * (l1 + 2 * l2 + 2 * l3 + l4))
}
#### NUMERICAL EXPLICIT FORWARD EULER PATANKAR SOLUTION
c1pteuler = rep(NA, length(t))
c2pteuler = rep(NA, length(t))
c1pteuler[1] = c10
c2pteuler[1] = c20
for (i in t[2:length(t)]){
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
p1 = c1pteuler[match(i, t) -1]
p2 = a * c1pteuler[match(i, t) -1]
d1 = p2
d2 = p1
c1pteuler[match(i, t)] = (c1pteuler[match(i, t) -1] + dt * p1) /
(1 + dt * d1 / c1pteuler[match(i, t) -1])
c2pteuler[match(i, t)] = (c2pteuler[match(i, t) -1] + dt * p2) /
(1 + dt * d2 / c2pteuler[match(i, t) -1])
c2pteuler[match(i, t)]  = c10 + c20 - c1pteuler[match(i, t)]
}
#### PLOTTING OF RESULTS
plot(t, c1, type = 'l', col = 'blue', ylim = c(-0.3, 1.3), xlab = 'time',
ylab = 'conc.')
lines(t, c1euler, type = 'l', col = 'blue', lty = 'dashed')
lines(t, c1rk, type = 'l', col = 'blue', lty = 'dotted')
lines(t, c1pteuler, type = 'l', col = 'blue', lty = 'dotdash')
lines(t, c2, col = 'red')
lines(t, c2euler, type = 'l', col = 'red', lty = 'dashed')
lines(t, c2rk, type = 'l', col = 'red', lty = 'dotted')
lines(t, c2pteuler, type = 'l', col = 'red', lty = 'dotdash')
legend(2., 1.1, legend=c("Analytical", "Explicit Euler", "Runge-Kutta 4th",
"Euler-Patankar"),
lty = c("solid","dashed","dotted",'dotdash')
)
# Burchard et al. (2003) "A high-order conservative Patankar-type discretisation
# for stiff systems of production–destruction equations
#### PROBLEM SET, TWO COUPLED ODES
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
dc1dt <- function(c1, c2, a){
return(c2 - a * c1)
}
dc2dt <- function(c1, c2, a){
return(a * c1 - c2)
}
#### PARAMETERS
a = 5
c10 = 0.9
c20 = 0.1
c1inf = (c10 + c20) / (a + 1)
dt = 0.3
t = seq(0, 4, dt)
c = c10/c1inf - 1
#### ANALYTICAL SOLUTION
c1 = (1 + c *  exp(-(a+1)* t)) * c1inf
c2 = c10 + c20 - c1
#### NUMERICAL EXPLICIT FORWARD EULER SOLUTION
c1euler = rep(NA, length(t))
c2euler = rep(NA, length(t))
c1euler[1] = c10
c2euler[1] = c20
for (i in t[2:length(t)]){
c1euler[match(i, t)] = c1euler[match(i, t) -1] +
dt * (c2euler[match(i, t) -1] - c1euler[match(i, t) -1] * a)
c2euler[match(i, t)] = c2euler[match(i, t) -1] +
dt * (a * c1euler[match(i, t) -1] - c2euler[match(i, t) -1])
}
#### NUMERICAL 4TH ORDER RUNGE KUTTA SOLUTION
c1rk = rep(NA, length(t))
c2rk = rep(NA, length(t))
c1rk[1] = c10
c2rk[1] = c20
for (i in t[2:length(t)]){
k1 = dc1dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
l1 = dc2dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
k2 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
l2 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
k3 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
l3 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
k4 = dc1dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
l4 = dc2dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
c1rk[match(i, t)] = c1rk[match(i, t) -1] +
dt * (1/6 * (k1 + 2 * k2 + 2 * k3 + k4))
c2rk[match(i, t)] = c2rk[match(i, t) -1] +
dt * (1/6 * (l1 + 2 * l2 + 2 * l3 + l4))
}
#### NUMERICAL EXPLICIT FORWARD EULER PATANKAR SOLUTION
c1pteuler = rep(NA, length(t))
c2pteuler = rep(NA, length(t))
c1pteuler[1] = c10
c2pteuler[1] = c20
for (i in t[2:length(t)]){
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
p1 = c1pteuler[match(i, t) -1]
p2 = a * c1pteuler[match(i, t) -1]
d1 = p2
d2 = p1
c1pteuler[match(i, t)] = (c1pteuler[match(i, t) -1] + dt * p1) /
(1 + dt * d1 / c1pteuler[match(i, t) -1])
c2pteuler[match(i, t)] = (c2pteuler[match(i, t) -1] + dt * p2) /
(1 + dt * d2 / c2pteuler[match(i, t) -1])
c2pteuler[match(i, t)]  = c10 + c20 - c1pteuler[match(i, t)]
}
#### PLOTTING OF RESULTS
plot(t, c1, type = 'l', col = 'blue', ylim = c(-0.3, 1.3), xlab = 'time',
ylab = 'conc.')
lines(t, c1euler, type = 'l', col = 'blue', lty = 'dashed')
lines(t, c1rk, type = 'l', col = 'blue', lty = 'dotted')
lines(t, c1pteuler, type = 'l', col = 'blue', lty = 'dotdash')
lines(t, c2, col = 'red')
lines(t, c2euler, type = 'l', col = 'red', lty = 'dashed')
lines(t, c2rk, type = 'l', col = 'red', lty = 'dotted')
lines(t, c2pteuler, type = 'l', col = 'red', lty = 'dotdash')
legend(2., 1.1, legend=c("Analytical", "Explicit Euler", "Runge-Kutta 4th",
"Euler-Patankar"),
lty = c("solid","dashed","dotted",'dotdash')
)
# Burchard et al. (2003) "A high-order conservative Patankar-type discretisation
# for stiff systems of production–destruction equations
#### PROBLEM SET, TWO COUPLED ODES
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
dc1dt <- function(c1, c2, a){
return(c2 - a * c1)
}
dc2dt <- function(c1, c2, a){
return(a * c1 - c2)
}
#### PARAMETERS
a = 5
c10 = 0.9
c20 = 0.1
c1inf = (c10 + c20) / (a + 1)
dt = 0.3
t = seq(0, 4, dt)
c = c10/c1inf - 1
#### ANALYTICAL SOLUTION
c1 = (1 + c *  exp(-(a+1)* t)) * c1inf
c2 = c10 + c20 - c1
#### NUMERICAL EXPLICIT FORWARD EULER SOLUTION
c1euler = rep(NA, length(t))
c2euler = rep(NA, length(t))
c1euler[1] = c10
c2euler[1] = c20
for (i in t[2:length(t)]){
c1euler[match(i, t)] = c1euler[match(i, t) -1] +
dt * (c2euler[match(i, t) -1] - c1euler[match(i, t) -1] * a)
c2euler[match(i, t)] = c2euler[match(i, t) -1] +
dt * (a * c1euler[match(i, t) -1] - c2euler[match(i, t) -1])
}
#### NUMERICAL 4TH ORDER RUNGE KUTTA SOLUTION
c1rk = rep(NA, length(t))
c2rk = rep(NA, length(t))
c1rk[1] = c10
c2rk[1] = c20
for (i in t[2:length(t)]){
k1 = dc1dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
l1 = dc2dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
k2 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
l2 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
k3 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
l3 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
k4 = dc1dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
l4 = dc2dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
c1rk[match(i, t)] = c1rk[match(i, t) -1] +
dt * (1/6 * (k1 + 2 * k2 + 2 * k3 + k4))
c2rk[match(i, t)] = c2rk[match(i, t) -1] +
dt * (1/6 * (l1 + 2 * l2 + 2 * l3 + l4))
}
#### NUMERICAL EXPLICIT FORWARD EULER PATANKAR SOLUTION
c1pteuler = rep(NA, length(t))
c2pteuler = rep(NA, length(t))
c1pteuler[1] = c10
c2pteuler[1] = c20
for (i in t[2:length(t)]){
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
p1 = c1pteuler[match(i, t) -1]
p2 = a * c1pteuler[match(i, t) -1]
d1 = p2
d2 = p1
p = sum(p1,p2)
d = sum(d1,d2)
c1pteuler[match(i, t)] = (c1pteuler[match(i, t) -1] + dt * p) /
(1 + dt * d / c1pteuler[match(i, t) -1])
c2pteuler[match(i, t)] = (c2pteuler[match(i, t) -1] + dt * p2) /
(1 + dt * d2 / c2pteuler[match(i, t) -1])
c2pteuler[match(i, t)]  = c10 + c20 - c1pteuler[match(i, t)]
}
#### PLOTTING OF RESULTS
plot(t, c1, type = 'l', col = 'blue', ylim = c(-0.3, 1.3), xlab = 'time',
ylab = 'conc.')
lines(t, c1euler, type = 'l', col = 'blue', lty = 'dashed')
lines(t, c1rk, type = 'l', col = 'blue', lty = 'dotted')
lines(t, c1pteuler, type = 'l', col = 'blue', lty = 'dotdash')
lines(t, c2, col = 'red')
lines(t, c2euler, type = 'l', col = 'red', lty = 'dashed')
lines(t, c2rk, type = 'l', col = 'red', lty = 'dotted')
lines(t, c2pteuler, type = 'l', col = 'red', lty = 'dotdash')
legend(2., 1.1, legend=c("Analytical", "Explicit Euler", "Runge-Kutta 4th",
"Euler-Patankar"),
lty = c("solid","dashed","dotted",'dotdash')
)
# Burchard et al. (2003) "A high-order conservative Patankar-type discretisation
# for stiff systems of production–destruction equations
#### PROBLEM SET, TWO COUPLED ODES
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
dc1dt <- function(c1, c2, a){
return(c2 - a * c1)
}
dc2dt <- function(c1, c2, a){
return(a * c1 - c2)
}
#### PARAMETERS
a = 5
c10 = 0.9
c20 = 0.1
c1inf = (c10 + c20) / (a + 1)
dt = 0.3
t = seq(0, 4, dt)
c = c10/c1inf - 1
#### ANALYTICAL SOLUTION
c1 = (1 + c *  exp(-(a+1)* t)) * c1inf
c2 = c10 + c20 - c1
#### NUMERICAL EXPLICIT FORWARD EULER SOLUTION
c1euler = rep(NA, length(t))
c2euler = rep(NA, length(t))
c1euler[1] = c10
c2euler[1] = c20
for (i in t[2:length(t)]){
c1euler[match(i, t)] = c1euler[match(i, t) -1] +
dt * (c2euler[match(i, t) -1] - c1euler[match(i, t) -1] * a)
c2euler[match(i, t)] = c2euler[match(i, t) -1] +
dt * (a * c1euler[match(i, t) -1] - c2euler[match(i, t) -1])
}
#### NUMERICAL 4TH ORDER RUNGE KUTTA SOLUTION
c1rk = rep(NA, length(t))
c2rk = rep(NA, length(t))
c1rk[1] = c10
c2rk[1] = c20
for (i in t[2:length(t)]){
k1 = dc1dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
l1 = dc2dt(c1rk[match(i, t) -1], c2rk[match(i, t) -1], a)
k2 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
l2 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k1, c2rk[match(i, t) -1] + 1/2 * dt * l1, a)
k3 = dc1dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
l3 = dc2dt(c1rk[match(i, t) -1] + 1/2 * dt * k2, c2rk[match(i, t) -1] + 1/2 * dt * l2, a)
k4 = dc1dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
l4 = dc2dt(c1rk[match(i, t) -1] + dt * k3, c2rk[match(i, t) -1] + dt * l3, a)
c1rk[match(i, t)] = c1rk[match(i, t) -1] +
dt * (1/6 * (k1 + 2 * k2 + 2 * k3 + k4))
c2rk[match(i, t)] = c2rk[match(i, t) -1] +
dt * (1/6 * (l1 + 2 * l2 + 2 * l3 + l4))
}
#### NUMERICAL EXPLICIT FORWARD EULER PATANKAR SOLUTION
c1pteuler = rep(NA, length(t))
c2pteuler = rep(NA, length(t))
c1pteuler[1] = c10
c2pteuler[1] = c20
for (i in t[2:length(t)]){
# dc1/dt = c2 - a c1
# dc2/dt = a c1 - c2
p1 = c1pteuler[match(i, t) -1]
p2 = a * c1pteuler[match(i, t) -1]
d1 = p2
d2 = p1
p = sum(p1,p2)
d = sum(d1,d2)
c1pteuler[match(i, t)] = (c1pteuler[match(i, t) -1] + dt * p1) /
(1 + dt * d1 / c1pteuler[match(i, t) -1])
c2pteuler[match(i, t)] = (c2pteuler[match(i, t) -1] + dt * p2) /
(1 + dt * d2 / c2pteuler[match(i, t) -1])
c2pteuler[match(i, t)]  = c10 + c20 - c1pteuler[match(i, t)]
}
#### PLOTTING OF RESULTS
plot(t, c1, type = 'l', col = 'blue', ylim = c(-0.3, 1.3), xlab = 'time',
ylab = 'conc.')
lines(t, c1euler, type = 'l', col = 'blue', lty = 'dashed')
lines(t, c1rk, type = 'l', col = 'blue', lty = 'dotted')
lines(t, c1pteuler, type = 'l', col = 'blue', lty = 'dotdash')
lines(t, c2, col = 'red')
lines(t, c2euler, type = 'l', col = 'red', lty = 'dashed')
lines(t, c2rk, type = 'l', col = 'red', lty = 'dotted')
lines(t, c2pteuler, type = 'l', col = 'red', lty = 'dotdash')
legend(2., 1.1, legend=c("Analytical", "Explicit Euler", "Runge-Kutta 4th",
"Euler-Patankar"),
lty = c("solid","dashed","dotted",'dotdash')
)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(tidyverse)
library(timeSeries)
library(statcomp)
library(zoo)
library(rLakeAnalyzer)
library(lubridate)
library(pracma)
library(broom)
library(ggpmisc)
library(patchwork)
library(Boruta)
library(caret)
library(relaimpo)
library(corrplot)
library(RColorBrewer)
strat <- read_csv('../data_processed/stratification.csv')
strat
